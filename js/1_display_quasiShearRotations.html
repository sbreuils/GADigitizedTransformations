<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>New Distribution of angles for bijective rotations</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="http://threejs.org/examples/js/libs/stats.min.js"></script>
<script src="lodash.js"></script>
<script  type="module">

import * as THREE from './jslibs/three.module.js';
import * as DG from '/GridUtilities.js';
import * as TRANSFO from '/DigitizedTransformation.js';
import * as ENTITIES from '/DigitizedGeometryCreation.js';

  // Our Javascript will go here.
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
  var camZPos = 3;//8; // 24
  camera.position.z = camZPos;

  console.log("init the scene ...")

  // add the grid of points
  let N=11;
  let posSquare = 3;
  let geometry_Grid = DG.createGrid(N);

  console.log("create the z2 grid ...")

  let XminScene = -(~~(N/2));
  let XmaxScene = (~~(N/2));


  // grid reflection decomment
  // let geometry_Cells = DG.createCells(N,XminScene,XmaxScene);
  // scene.add(geometry_Cells );


  // console.log("reflect the z2 grid using a bijective digitized reflection  ...")

  // // let k = 1.0; // bijective digitized reflection parameters
  // // let a = -k;
  // // let b = k+1.0;
  // let a = -1.0;
  // let b = 4.0;


  // let reflectedGrid = TRANSFO.digitalReflectionOfPoints(geometry_Grid,[a,b,0.0,0.0]);
  // scene.add(reflectedGrid);

  // let setRemaindersVectors = DG.setOfRemainders(reflectedGrid,0xff0000);
  // scene.add(setRemaindersVectors);


  // // this is to check bijectivity for lower set of points
  // let setRemaindersVectorsTrimed = DG.setOfRemaindersRestreined(reflectedGrid,0x0fff00,a,b,N);
  // scene.add(setRemaindersVectorsTrimed);
  
  scene.add(DG.createCircle());
  scene.add(...DG.createXYAxis(-1.0,1.0));

  let bijectiveReflectionDistrib = TRANSFO.pointsMakingReflectionBijective(30);
  scene.add(bijectiveReflectionDistrib);


  // // have to compute the digitization and the other digitized reflection
  // let digitizedreflectedGrid = new THREE.Geometry();
  // digitizedreflectedGrid.vertices = _.cloneDeep(reflectedGrid.geometry.vertices);//JSON.parse(JSON.stringify(points_i.geometry.vertices));
  // digitizedreflectedGrid.colors = _.cloneDeep(reflectedGrid.geometry.colors);
  // discretizeGeometry(digitizedreflectedGrid);
  // // scene.add(digitizedreflectedGrid);

  // let doubleReflectedGrid = digitalReflectionOfPoints(new THREE.Points(digitizedreflectedGrid,geometry_Grid.material),[a,b,0.0,0.0]);
  // // scene.add(doubleReflectedGrid);
  // let setRemaindersDoubleReflectedVectors = setOfRemainders(doubleReflectedGrid,0x00ff00);
  // // scene.add(setRemaindersDoubleReflectedVectors);


  /////////////////////////         TIME TO RENDER        ///////////////////////////////
  // add the renderer to put the scene
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.setClearColor(0xffffff);
  document.body.appendChild( renderer.domElement );

  // Animate function and call it
  var animate = function () {
    requestAnimationFrame( animate );

    renderer.render( scene, camera );
  };

  animate();



</script>
</body>
</html>
